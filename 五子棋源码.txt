#include<stdio.h>
#include<stdlib.h>
#include<Windows.h>
#include<time.h>
extern int Arr[300] = { 0 };
extern int flag = NULL;
struct Person1{//O
	int steps[75];
	int index;
	int victory;
}person1;
struct Person2{//*
	int steps[75];
	int index;
	int victory;
}person2;
void showBoard(){//30*10
	int index = 0;
	for (int k = 0; k < 30; k++)
		printf("--");
	printf("-");
	printf("\n");
	for (int i = 0; i < 10; i++){
		printf("|");
		for (int j = 0; j < 30; j++){
			printf("%c|", Arr[index]);
			index++;
		}
		printf("\n");
		for (int k = 0; k < 30; k++)
			printf("--");
		printf("-");
		printf("\n");
	}
}
void GameOver(int victory, COORD *coord){
	//最后一次刷新棋盘
	system("cls");
	showBoard();
	Sleep(2000);
	//刷新页面进入结束流程
	system("cls");
	printf("GameOver\n");
	//释放内存
	coord = NULL;
	if (victory){
		printf("玩家1获胜");
	}
	else{
		printf("玩家2获胜");
	}
	Sleep(2000);
	system("cls");
	//清除所有数据并开始下一局
	Arr[300] = NULL;
	flag = NULL;
	main();
}
void test(int steps[], int index, int count, int victory, COORD *coord){
	int i, j, counter, k;
	for (i = 0; i < index; i++){
		counter = 1;
		k = steps[i];
		for (j = i + 1; j < index; j++){
			if (k + count == steps[j]){
				k = steps[j];
				counter++;
			}
		}
		if (counter >= 5){
			GameOver(victory, coord);
		}
	}
}
void examine(int steps[], int index, int victory, COORD *coord){
	int i, j, t = 0, counter, k;
	//将存步数的数组进行从小到大排序
	for (i = 0; i < index; i++){
		for (j = i + 1; j <index; j++){
			if (steps[i] > steps[j]){
				t = steps[i];
				steps[i] = steps[j];
				steps[j] = t;
			}
		}
	}
	//检查是否游戏结束(赢)(横向)
	for (i = 0; i < index; i++){
		//这里等于1而不是等于0的原因:
		//刚开始的k就是一次
		counter = 1;
		k = steps[i] + 1;
		for (j = i + 1; j < index; j++){
			if (k == steps[j]){
				k++;
				counter++;
			}
		}
		if (counter >= 5){
			GameOver(victory, coord);
		}
	}
	//检查是否游戏结束(赢)(纵向)
	test(steps, index, 30, victory, coord);
	//检查是否游戏结束(斜)
	test(steps, index, 29, victory, coord);
	//斜2
	test(steps, index, 31, victory, coord);
}
void Position(COORD *coord){
	int control = NULL;
	while (1){
		control = getch();
		//printf("%d",control);
		if (control == 115 && coord->Y != 19 && flag % 2 == 1 || control == 80 && coord->Y != 19 && flag % 2 == 0){
			coord->Y = coord->Y + 2;
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), *coord);
		}
		else if (control == 119 && coord->Y != 1 && flag % 2 == 1 || control == 72 && coord->Y != 1 && flag % 2 == 0){
			coord->Y = coord->Y - 2;
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), *coord);
		}
		else if (control == 97 && coord->X != 1 && flag % 2 == 1 || control == 75 && coord->X != 1 && flag % 2 == 0){
			coord->X = coord->X - 2;
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), *coord);
		}
		else if (control == 100 && coord->X != 59 && flag % 2 == 1 || control == 77 && coord->X != 59 && flag % 2 == 0){
			coord->X = coord->X + 2;
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), *coord);
		}
		else if (control == 32||control == 13){
			int count, repeat = 1;
			count = ((coord->Y - 1) / 2) * 30 + coord->X / 2;
			if (flag % 2 == 1)
			{
				for (int i = 0; i <= person1.index; i++){
					if (person1.steps[i] == count || person2.steps[i] == count){
						repeat = 0;//检查是否含有重复
						break;
					}
				}
				if (repeat){
					Arr[count] = '*';
					person1.steps[person1.index] = count;
					person1.index++;
					examine(person1.steps, person1.index, person1.victory, coord);
				}
				else{//如果含有重复的，就重新调用
					Position(coord);
				}
			}
			else{
				for (int i = 0; i <= person2.index; i++){
					if (person1.steps[i] == count || person2.steps[i] == count){
						repeat = 0;//检查是否含有重复
						break;
					}
				}
				if (repeat){
					Arr[count] = 'O';
					person2.steps[person2.index] = count;
					person2.index++;
					examine(person2.steps, person2.index, person2.victory, coord);
				}
				else{//如果含有重复的，就重新调用
					Position(coord);
				}
			}
			//刷新控制台
			system("cls");
			//显示新的页面
			showBoard();
			//根据flag来决定玩家的先后顺序
			flag++;
			SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), *coord);
		}
	}
}
int decrementTime(COORD * time,int count){//递归完成定时器
	count--;
	if (count >= 0){
		Sleep(1000);
		SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),*time);
		printf("%d", count);
		decrementTime(time, count);
	}
	else{
		return 0;
	}
}
void regulation(){
	system("cls");
	printf("**********************************\n");
	printf("***          游戏规则          ***\n");
	printf("*** 1:游戏为双人游戏           ***\n");
	printf("*** 2:每次玩家输入行和列       ***\n");
	printf("*** 3:游戏开始前请先商量好(1|2)***\n");
	printf("*** 4:系统会决定(1|2)的先后顺序***\n");
	printf("*** 5:祝您游戏愉快             ***\n");
	printf("**********************************\n");
	int count = 5;
	COORD *time = (int *)malloc(sizeof(int)* 6);
	printf("%d秒后自动退出...",count);
	time->Y = 8;
	time->X = 0;
	decrementTime(time,count);
}
void Cover(){
	system("cls");
	printf("*************************\n");
	printf("*** 1：开始游戏(Play)****\n");
	printf("*** 2：退出游戏(Exit)****\n");
	printf("*** 3：查看游戏规则******\n");
	printf("*************************\n");
	printf("请输入>>");
}
void initialization(COORD *coord){
	//初始化棋的空位
	for (int i = 0; i < 300; i++)
		Arr[i] = ' ';
	//显示光标初始位置
	coord->X = 31;
	coord->Y = 11;
	//初始化玩家走的步数
	person1.index = 0;
	person2.index = 0;
	person1.steps[75] = 0;
	person2.steps[75] = 0;
	person1.victory = 1;
	person2.victory = 0;
}
void BeginGame(COORD *coord){
	srand((int)time(NULL));
	system("cls");
	flag = rand() % 2 + 1;//获取玩家的先后顺序
	printf("玩家%d优先", flag);
	Sleep(1500);
	system("cls");
	showBoard();
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), *coord);
	//flag=1，person1优先
	Position(coord);
}    
main(){
	int directive = 0;
	//指针指向坐标结构体(并在堆空间里开内存)
	COORD *coord = malloc(256 * sizeof(char));
	initialization(coord);//初始化数据
	while (1){
		Cover();
		scanf_s("%d", &directive);
		switch (directive){
		case 1:
			BeginGame(coord);
			break;
		case 2:
			exit(1);//结束整个程序
			break;
		case 3:
			regulation();
			break;
		default:
			printf("输入指令错误，请重新输入...");
			Sleep(1000);
		}
	}
}